# single line comment
##
Multi line comment

-> Commas are optional

Each code needs to be wrapped in a module
The module has a name and the defines the backend
languge.

##
module("main" "php"){

    ##
        You can set rules for all scopes
        Scopes inherit the rules from the parent scope
    ##
    use RuleSet(
        no_fuck_around = true
    )

    ##
        Open a other module
        -> visible only for the scope the
        "open" is in, as well as all child scopes
    ##
    open(STD){
        use fmt.out
    }

    my_const :: 1

    my_fn:: fn(a:Int b:Int) -> Int {
        return a + b
    }

    MyEnum :: enum{ KEK :: 1 LOL :: 2 ROFL :: 3 }

    ##
    A trait is basically a interface, as well as a code reuse
    vehicle for object composition.
    This depends on the use.
    ##
    MyTrait :: trait{

       field: Int

       static_field :: 123

       abstract_method : Fn(Self)->String

       abstract_static_method :: Fn()->String

       method_to_share : fn(self){
          out( self.field )
       }

    }

    # structs and traits NEED TO BE UpperCase


    ##
        Structs allow to structure data.

        You can use traits to compose structs or to
        ensure functionality on structs.

        Structs can have methods and static methods, so
        a struct can also act as a name-space.
    ##
    MyStruct :: struct{

        use MyTrait

        some_other_field: Int

        abstract_method : fn(self) -> String {
          return "implemented" & self.field
        }

        abstract_static_method :: fn(scope)->String {
            return "implemented"+ scope.static_field
        }

    }


    Utils :: struct{
        use RuleSet(namespace = true) #  this struct can only contain static methods and other static field values
        add :: fn(a:Int b:Int) -> Int {
            return a + b
        }
    }

    # we can use ruleset to disable the creation of an struct via literal
    # or even make fields private
    ILoveOOP :: struct{

       use RuleSet(
         outside_literal_creation = false
         private_fields = true
       )

       a: Bool
       b: MyStruct

       new :: fn() -> self {
          return self(
             a = false,
             b = MyStruct()
          )
       }

    }

    # we can put together rulesets
    # the ruleset itself has the const-values only rule
    # so you cannot put in expressions, only literals
    strict_function_rules :: RuleSet(
        allow_variables = false
    )

    # functions can only see const values from the top level scope
    foo :: fn(){
       # nice we can set the rules for our function
       use strict_function
    }
    other_foo :: fn(){
       # nice we can set the rules for our function
       use strict_function
    }

    number_guess :: fn(number: Int ) -> Union(Bool, Error, String){
       if number < 0 {
          return ->(bool = false) #-> shorthand for return type construction literal Union(Bool, Error, String)
          # return Union(Bool, Error, String)(bool = false)
       }elif number > 100 {
          return ->(error = Error("You suck"))
       }else{
          return ->(string = "Eat Ass!")
       }
    }

    get_option :: fn() -> Option(MyStruct) {
      return ->(some = false)
    }

    main :: fn(){

        local_const :: MyStruct(
           field = 124
           some_other_field = 124
        )

        variable := MyStruct(
           field = 124
           some_other_field = 124
        )

        variable.field = 99999

        if my_struct := get_option?value {
            out("nice we got a value")
        }else{
            out("bad...")
        }

        myList := List(MyStruct)()

        myMap := Map(String, MyStruct)(
           "Kacke" = MyStruct(
              field = 124
              some_other_field = 124
           )
        )

        myList2 := List(Int)(1 2 3 4 5 6 7 8 9)
        # the -> before a ( means assume the type of the construction literal from the left hand side

        localf :: fn(a: List(Int)){}
        localf(->(1 2 3 4 5 6 7))

        for i := 0 .. myList2.len {
            out(i)
        }

        for i := 0 .. myList2.len; 2{
            out(i)
        }

        if(b := number_guess()?bool){
            out("we got " + b)
        }elif(s := _?string){
            out(s)
        }elif(err:= _?error){
            out(err.message)
            out(err.traceback)
        }


        b := 14

        {
          a := 124 + b
        }

        # a is not defined here

        (){
          a := 124 # b isnot defined here
          # since the () makes this a capture block
        }


        (b){
          a := 124 + b
        }

        {


         a := (b) -> { # this is a return block
            return 124 + b
         }

         {
             a := -> {  # this is a return block
                return 124 + b
             }
         }

        }

    }





}