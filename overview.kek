# single line comment
##
Multi line comment

-> Commas are optional

Each code needs to be wrapped in a module
The module has a name and the defines the backend
languge.

##

# bytecode for embedding into c code like lua
# and then we can compile it into bytecode
# and have c-interop
module("main" "php"){ # "js", "php", "c", "bytecode"

    ##
        You can set rules for all scopes
        Scopes inherit the rules from the parent scope
    ##
    use RuleSet(
        no_fuck_around = true
    )

    ##
        Open a other module
        -> visible only for the scope the
        "open" is in, as well as all child scopes
    ##
    open(STD){
        use fmt.out
    }

    my_const :: 1

    my_fn:: fn(a:Int b:Int) -> Int {
        return a + b
    }

    MyEnum :: enum{ KEK :: 1 LOL :: 2 ROFL :: 3 }

    ##
    A trait is basically a interface, as well as a code reuse
    vehicle for object composition.
    This depends on the use.
    ##
    MyTrait :: trait{

       field: Int

       static_field :: 123

       abstract_method : Fn(Self)->String

       abstract_static_method :: Fn()->String

       method_to_share : fn(self){
          out( self.field )
       }

    }

    # structs and traits NEED TO BE UpperCase


    ##
        Structs allow to structure data.

        You can use traits to compose structs or to
        ensure functionality on structs.

        Structs can have methods and static methods, so
        a struct can also act as a name-space.
    ##
    MyStruct :: struct{

        use MyTrait
        # this adds all the runtime type info
        # methods and data to this struct.
        use RuntimeTypeInformation

        some_other_field: Int

        abstract_method : fn(self) -> String {
          return "implemented" & self.field
        }

        # scope is the static scope of the struct definition
        abstract_static_method :: fn(scope)->String {
            return "implemented"+ scope.static_field
        }

    }


    Utils :: struct{
        use RuleSet(namespace = true) #  this struct can only contain static methods and other static field values
        add :: fn(a:Int b:Int) -> Int {
            return a + b
        }
    }

    # we can use ruleset to disable the creation of an struct via literal
    # or even make fields private
    ILoveOOP :: struct{

       use RuleSet(
         outside_literal_creation = false
       )

       a: Bool
       b: MyStruct

       new :: fn() -> self {
          return self(
             a = false,
             b = MyStruct()
          )
       }

    }

    # we can put together rulesets
    # the ruleset itself has the const-values only rule
    # so you cannot put in expressions, only literals
    strict_function_rules :: RuleSet(
        allow_variables = false
    )

    # functions can only see const values from the top level scope
    foo :: fn(){
       # nice we can set the rules for our function
       use strict_function
    }
    other_foo :: fn(){
       # nice we can set the rules for our function
       use strict_function
    }

    number_guess :: fn(number: Int ) -> Union(Bool, Error, String){
       if number < 0 {
          return ->(bool = false) #-> shorthand for return type construction literal Union(Bool, Error, String)
          # return Union(Bool, Error, String)(bool = false)
       }elif number > 100 {
          return ->(error = Error("You suck"))
       }else{
          return ->(string = "Eat Ass!")
          # return -> induces the return type
       }
    }

    get_option :: fn() -> Option(MyStruct) {
      return ->(some = false)
    }

    main :: fn(){

        local_const :: MyStruct(
           field = 124
           some_other_field = 124
        )

        variable := MyStruct(
           field = 124
           some_other_field = 124
        )

        variable.field = 99999

        if my_struct := get_option?value {
            out("nice we got a value")
        }else{
            out("bad...")
        }

        myList := List(MyStruct)()

        myMap := Map(String MyStruct)(
           "Kacke" = MyStruct(
              field = 124
              some_other_field = 124
           )
        )

        myList2 := List(Int)(1 2 3 4 5 6 7 8 9)
        # the -> before a ( means assume the type of the construction literal from the left hand side

        localf :: fn(a: List(Int)){}
        localf(->(1 2 3 4 5 6 7))

        for i := 0 .. myList2.len {
            out(i)
        }

        for i := 0 .. myList2.len; 2{
            out(i)
        }

        if(b := number_guess()?bool){
            out("we got " + b)
        }elif(s := _?string){
            out(s)
        }elif(err := _?error){
            out(err.message)
            out(err.traceback)
        }


        b := 14

        {
          a := 124 + b
        }

        # a is not defined here

        (){
          a := 124 # b isnot defined here
          # since the () makes this a capture block
        }


        a := ->( 1 2 4 5 6 ) #  type induced

        tuple := ->(1 true "kek" 1.2) # type == Tuple(Int, Bool, String, Float)

        b :: ->(
            "KEK" = "LOL"
        )

        needs_vector(->(x=2 y=3 z=4))

        (b){
          a := 124 + b
        }

        {


         a := (b) -> { # this is a return block
            return 124 + b
         }

         {
             a := -> {  # this is a return block
                return 124 + b
             }
         }

        }

    }

    ##
        Local keyword
        -> before a field means
        that this field can not leave the scope

        -> local in a function means that the variable
        can not be set to any value from outside the
        using scope.
        -> this means, that if we share a reference we know
        that it will not appear in another portion of persistent
        state.

    ##
    local_struct :: struct{
        local a: Int
        local b: Int
        local my: MyStruct

        ##
            My striuct can be read but not set to outside the scope
        ##
        getmy_as_local:: fn() -> local MyStruct {
            return my
        }

    }

    instances :: List(MyStruct)

    {

        instances.append(MyStruct(
            field = 124
            some_other_field = 124
        ))

        local my_struct := MyStruct(
            field = 124
            some_other_field = 124
        )

        instances.append(my_struct) # this is not allowed

        local mys2 = my_struct.getmy_as_local() # this is allowed

        instances.append(my_struct) # this is not allowed
        # error would be: Type-Error local value my_struct is not allowed to leave the scope
        # append would need to consume a local value
        # but this is not the case with append, since
        # append would assign the value to the inner state

        # local in the variable list is the promise that the variable
        # will not be set to from outside the scope
        # so if the function has concluded
        # no references to the passed in variable will exist
        mf :: fn(m: local MyStruct) {
            out(m.field)
        }

        # const means value cannot be changed
        # but could "leave the scope"


        # maybe we can create "managed" values?
        # which are refernce counted??

    }

    # offer full c interop by offering pointers and structs
    # pointer are disabled in modules by default but can be
    # enabled.
    # so we can write code that calls s code directly in kek

    # do we need a cfn keyword to define the c functions
    cfn





}


